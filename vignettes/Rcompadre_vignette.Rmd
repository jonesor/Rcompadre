---
title: "Introduction to Rcompadre"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to Rcompadre}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

![logo](images/Logo_COMADRE_Vertical_Color.png)    ![logo](images/Logo_COMPADRE_Vertical_Color.png)

The COMADRE and COMPADRE databases together contain several thousand (mostly) published matrix population models (MPMs) for species from across the diverse tree of life.

The purpose of Rcompadre is to provide utilities for accessing, selecting, and transforming MPMs from particular species of interest, and groups of species for comparative demographic analyses.

Rcompadre integrates with the RPackage Rage, which provides functions to calculate different life history quantities of interest.

## What the vignette covers

- Introduction - what are COMADRE and COMPADRE?
- Structure of the database
- What metadata are included?
- Querying the database
- Conducting some large-scale comparative analysis

## Obtaining an MPM
This part explains how to get matrices out of the COMADRE and COMPADRE databases.

_Once data base is queryable, we'll need to write functions to access it from R. For now, leave this part blank and return once we have an idea of what that workflow looks like._

The package comes with small, sample versions of COMPADRE and COMADRE to help prototype code before running large queries. You can load them by running the folowing: 

```{r echo = TRUE, comment=">"}

library(Rcompadre)
data(Comadre)
data(Compadre)
  
```
The two databases are identical in gross structure, so the following code will apply to both.

Let's imagine you want to get matrices for all *Ursus maritimus* (polar bear) species from the database.

Once you have loaded the file, you should see it in your `Environment`. It will be called `Comadre` and is a stored as a formal class `CompadreData` (the class is the same for both COMPADRE and COMADRE).

### A quick note about S4 addressing
`Rcompadre` utilizes S4 objects to house the data. If you are already familiar with them, skip ahead. If not, the main thing you will need to remember is that accessing components of an S4 object is a bit different than accessing components of an S3 object (e.g. a data.frame or list). S4 objects are addressed using the **@** symbol rather than the **$** symbol. If you're interested in learning more, a far more comprehensive overview of how S4 objects work can be found [here](http://adv-r.had.co.nz/S4.html). And now, back to the demography!

You can check the structure of the object by typing the following, whereupon you will see there are 3 parts:

```{r, comment=">"}

slotNames(Comadre)
```

The `metadata` part is a dataframe that contains information about the matrix models contained in the database.

There are lots of columns in the dataframe, and you could subset the data by any of them.

```{r, comment=">"}

names(Comadre@metadata)
```

You can find the details of what these columns are in the User Guides or by running `?Comadre`.

Since we are interested in getting data for a species matching a particular name (*Ursus maritimus*), we'll need to examine the column called `SpeciesAccepted`, which is the currently accepted binomial species name. `RCompadre` provides a suite of utility functions to make working with the data base a bit easier. We'll use the `subsetDB` function to find all the matrices for _Ursus maritimus_.

```{r, echo = TRUE, comment = ">"}

PolarBears <- subsetDB(db = Comadre, sub = SpeciesAccepted == 'Ursus maritimus')

```

To get the matrix for any of these we need to access the `mat` part of the database.

Let's look at the first one using `PolarBears@mat[[1]]`

You will note that `mat` actually consists of 5 objects: a  called dataframe called `matrixClass` and 4 separate matrices called `matA`, `matU`, `matF` and `matC`. The  matrix most of you will want is the **A** matrix. The others are sub-parts of this matrix that represent processes of survival, fertility and clonality. These three matrices sum to the **A** matrix.


You can isolate **just** the **A** matrix like this, renaming it `x`:

```{r comment=">"}
x <- PolarBears@mat[[1]]@matA
x
```

Now you can use this matrix to do the analysis of interest.

You'll probabaly note that the stage class information is omitted from `matA`. To access this information directly, you can call `PolarBears@mat[[1]]@matrixClass`

## Simple outputs
This example produces some basic output such as the population growth rate ($\lambda$) and damping ratio (Caswell 2001) for a subset of species and populations given some selection criteria.

First, use `subsetDB` to subset the database to the data of interest: only mean matrices for bony fish from studies of 3 years duration or longer, and with a  matrix dimension of 3 or greater.

```{r, comment=">"}
BonyFish <- subsetDB(Comadre, MatrixComposite == "Mean" &
                              Class == "Actinopterygii" &
                              StudyDuration >= 3 &
                              MatrixDimension > 3)
```

These matrices can now be analyzed by applying functions in a loop, or by using `lapply`.

For example, to calculate population growth rate and damping ratio for
the subset of matrices, first create an empty `data.frame` to accommodate the output

```{r, comment=">"}
output <- data.frame(lambdas = rep(NA, length(BonyFish@mat)),
                     damps = rep(NA, length(BonyFish@mat)))
```

and then use the functions in `popbio` package to derive demographic output (the user may need to install the package first).

```{r, comment=">"}
library(popbio)
```


```{r, comment=">"}
for (i in seq_len(length(BonyFish@mat))){
    output$lambdas[i] <- Re(eigen(BonyFish@mat[[i]]@matA)$value)[1]
    output$damps[i] <- damping.ratio(BonyFish@mat[[i]]@matA)
}
```

To examine the output:

```{r, comment=">"}
output
```

These parameters are presented in the same order as the `metadata` so we could also add the species name to this `data.frame`:

```{r, comment=">"}
data.frame(Species = BonyFish@metadata$SpeciesAccepted, output)
```

Plot the population growth rates and damping ratios derived from these matrices. In this plot, the vertical, dashed red line indicates that the population growth rate = 1 (or log ($\lambda$) = 0)

```{r, comment=">", fig.height=5, fig.width=7}
par(mfrow = c(1,2))
hist(log(output$lambdas),
     xlab = expression(paste('Log(', lambda,')')),
     col = "gold", main = "")
abline(v=0,col = "red", lwd = 4, lty = 3)
hist(output$damps, xlab = "Damping ratio",
     col = "brown", main = "")
```

## Geographic distribution

This example produces on a world map the viability (population growth rate $\lambda$ > 1, $\lambda$ = 1, $\lambda$ < 1) of a subset of studied populations given some selection criteria, and color-codes the location of each population according to the value of $\lambda$.

First, subset mean matrices for all Carnivora in the wild in the northern hemisphere, with no instances for survival > 1, for which matrices have been split into **A** = **U** + **F** + **C**, and for which reproduction was explicitly modeled.


```{r, comment=">"}
Carnivores <- subsetDB(Comadre, MatrixComposite == "Mean" &
                                Order == "Carnivora" &
                                MatrixCaptivity == "W" &
                                Lat > 0 &
                                SurvivalIssue < 1 &
                                MatrixSplit == "Divided" &
                                MatrixFec == "Yes")
```

To calculate population growth rate for the subset matrices, we can first create an empty `data.frame` to accommodate the output:

```{r, comment=">"}
output <- data.frame(lambdas = rep(NA, length(Carnivores@mat)))
```


Or create an empty variable in the `metadata` data frame to accommodate output from lambda calculations:

```{r, comment=">"}
Carnivores@metadata$lambdas <- NA
```


Then, create a `for` loop to examine each matrix in turn. Here it may be advisable to use the function `tryCatch` as a wrapper to cope with the situation if/when the function in the loop fails:

```{r, comment=">"}
for (i in seq_len(length(Carnivores@mat))){
  tryCatch({
    Carnivores@metadata$lambdas[i] <- Re(eigen(Carnivores@mat[[i]]@matA)$value)[1]
  }, error = function(e){})
}
```

Now we can create a vector of color hex codes that can be applied according to the estimate of $\lambda$. This is done using the `colorRampPalette` function to go from green for high values of $\lambda$, to red for low values of $\lambda$. Here `paste` is used to append a value of `90` to the hex codes to allow transparency for aesthetic reasons.

```{r, comment=">"}

rampfunc <- colorRampPalette(c("green", "red"))
colVect <- rampfunc(100)
colVect <- paste(colVect, "90", sep = "")
s1 <- seq(min(Carnivores@metadata$lambdas, na.rm=TRUE),
          max(Carnivores@metadata$lambdas, na.rm=TRUE),
          length.out = 100)
```

First, load the `maps` package (and install it if necessary). Then plot the world map and overlay the points from our data, color coded by value of $\lambda$. In this case, the points are jittered slightly to improve visibility of nearby populations.

```{r, comment=">", fig.height=6, fig.width=8}
library(maps)
map("world", col = "gray", fill = TRUE, bg = "light blue",
    xlim = c(-175, 176), ylim = c(-60, 85), border = "white")

points(jitter(Carnivores@metadata$Lon, 0.6), 
       jitter(Carnivores@metadata$Lat, 0.6),
       col = colVect[findInterval(Carnivores@metadata$lambdas, s1)],
       cex = 2, 
       pch = 16)
```

## Obtaining references

The following example illustrates how to check and find the full references and DOI for the publications used in COMADRE. See also Supporting Information Appendix S4 below.

The code relies on the package `rcrossref` (https://github.com/ropensci/rcrossref) which queries *CrossRef*, an official Digital Object Identifier (DOI) Registration Agency of the International DOI Foundation. Thus you will first need to load the package (and install it if necessary):

```{r,eval=FALSE}
install.packages("rcrossref")
```

```{r, comment=">"}
library(rcrossref)
library(dplyr)
```

The `rcrossref` package has a convenient function, `cr_search_free` which conducts a free-text search of the CrossRef database. To use it, one needs to provide some query text, so in this case we can simply create a text string by concatenating the authors, journal and year of publication from COMADRE. 

As an create an example data set by subsetting COMADRE to studies with a matrix dimension >= 3, that represent mean, unmanipulated conditions duration > 3 years, where sexual reproduction has been modeled explicitly, the matrices are split into U, F and C, and there are no issues with stage-specific survival >1.

```{r, comment=">"}
ExData <- subsetDB(Comadre, MatrixDimension >= 3  &
                            MatrixComposite == "Mean" & 
                            MatrixTreatment == "Unmanipulated" & 
                            StudyDuration > 3 & 
                            MatrixFec == "Yes" & 
                            MatrixSplit == "Divided" & 
                            SurvivalIssue < 1)
```

To obtain the full references for all the studies used to create the plots above, first extract the column `DOI.ISBN` from the `ExData` object and remove any that don't have a DOI or ISBN number.

```{r,comment=">"}
DOIs <- ExData@metadata$DOI.ISBN %>%
  .[!is.na(.)]
```

Armed with the DOIs, it is easy to obtain the full title, author list etc. from CrossRef in a range of formats using the function `cr_cn`. 

```{r,comment=">"}

Citations <- cr_cn(dois = DOIs, format = "text", style = "apa")
```

Be aware that running this for a large number of studies may take a bit of time and adjust your expectations accordingly. 

## Checking taxonomy 

The following R code illustrates how to update the taxonomy used in COMADRE using the R package `taxize` (Chamberlain & SzÃ¶cs 2013) to query the Catalogue of Life (http://www.catalogueoflife.org) with the names used by the source publication authors in COMADRE. 

The function `classification` in `taxize` allows the programmatic querying of databases including the Catalogue of Life. For example:

```{r,eval = TRUE,echo=TRUE}
library(taxize)
```


```{r,comment=">"}
classification("Daphnia magna", db = 'col')
```

One can capitalise on this for COMADRE. 

First load the required package, `taxize`.

```{r, warning = FALSE, message = FALSE}
library(taxize)
library(stringr)
library(dplyr)
```

Now make a new vector called `SpeciesBinomial` by concatenating the accepted genus and author supplied species names together. This is necessary, rather than simply using `SpeciesAccepted`, because `SpeciesAccepted` retains the infra-specific information which is not used by the following code.  Additionally, Some species do not have an epithet (e.g. *Cottus* sp.). Therefore, to search the Catalogue of Life effectively, we need to remove the 'sp.' text and trim off the trailing whitespaces. We'll make use of the pipe (`%>%`) operator to streamline our code a bit too.


```{r, comment=">"}
ExData@metadata$SpeciesBinomial <- vapply(ExData@metadata$SpeciesAuthor, 
                                          FUN = function(x) stringr::str_split(x, '_')[[1]][2],
                                          FUN.VALUE = '') %>%
  paste(ExData@metadata$Genus, .,  sep = ' ') %>%
  gsub('sp\\.', '', .) %>%
  str_trim()

```


Because species appear in the database numerous times it is advisable for efficiency reasons to make a unique subset of the data:

```{r, comment=">"}
temp <- unique(ExData@metadata[, c("SpeciesBinomial", 
                                   "Genus", "Family", 
                                   "Order", "Class", 
                                   "Phylum", "Kingdom")])
```

This dataset is still quite large (`r length(temp)` species), so here I will just obtain the information for the first 5 species.

```{r, comment=">"}
temp <- temp[1:5, ]
```

This is accomplished using the `classification` function which repeatedly queries the Catalogue of Life for each entry. In this case, we have asked it to only return 1 row as whenever there is an uncertainty as to which species is intended, the software prompts the user to select a species from a list. However, setting `rows` to a value > 1 will allow for interactive selection when there is more than 1 option.

```{r, comment=">"}
x <- classification(temp$SpeciesBinomial, db='col', rows = 1)
```

The object produced by this code is a `list` with elements corresponding to each species. Thus `x[[1]]` will return the first species etc. One can also address the list by element name, which is defined by the query that was submitted e.g. `x[["Acipenser fulvescens"]]`

```{r,comment=">"}
x[[1]]
```

Thus, to acquire the taxonomic Order of the species of interest one would use:

```{r,comment=">"}
x[[1]]$name[x[[1]]$rank == "order"]
```

One can run through this list object in a loop to compare the information held in COMADRE, with that produced by the query to Catalogue of Life. For example, to check the Orders of the 5 species held in `temp`

```{r,comment=">", tidy.opts=list(blank=TRUE, width.cutoff=60)}
temp$OrderOK <- NA

for(i in seq_len(length(temp$SpeciesBinomial))){
n <- temp$SpeciesBinomial[i]
dat <- x[[n]]
CoL_Order <- dat$name[dat$rank == "order"]
if(temp$Order[i] == CoL_Order){
  temp$OrderOK[i] <- "OK"
} else {
    temp$OrderOK[i] <- "Differs!"}
}
```

which will add an extra column called `OrderOK` to the `temp` data frame:

```{r,comment=">"}
temp
```
This approach can naturally be repeated for each part of the taxonomy.

## Useful links

The COMPADRE and COMADRE website http://www.compadre-db.org (download the latest data files from here).


[COMPADRE User Guide PDF](https://github.com/jonesor/compadreDB/raw/master/COMPADRE-UserGuide/COMPADRE-UserGuide.pdf)


[COMADRE User Guide PDF](https://github.com/jonesor/compadreDB/raw/master/COMADRE-UserGuide/COMADRE-UserGuide.pdf)
