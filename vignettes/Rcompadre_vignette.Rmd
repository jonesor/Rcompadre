---
title: "Introduction to Rcompadre"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to Rcompadre}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

![logo](images/Logo_COMADRE_Vertical_Color.png)    ![logo](images/Logo_COMPADRE_Vertical_Color.png)

The COMADRE and COMPADRE databases together contain several thousand (mostly) published matrix population models (MPMs) for species from across the diverse tree of life.

The purpose of Rcompadre is to provide utilities for accessing, selecting, and transforming MPMs from particular species of interest, and groups of species for comparative demographic analyses.

Rcompadre integrates with the RPackage Rage, which provides functions to calculate different life history quantities of interest.

## What the vignette covers

- Introduction - what are COMADRE and COMPADRE?
- Structure of the database
- What metadata are included?
- Querying the database
- Conducting some large-scale comparative analysis

## Obtaining an MPM
This part explains how to get matrices out of the COMADRE and COMPADRE databases.

_Once data base is queryable, we'll need to write functions to access it from R. For now, leave this part blank and return once we have an idea of what that workflow looks like._

The package comes with small, sample versions of COMPADRE and COMADRE to help prototype code before running large queries. You can load them by running the folowing: 

```{r echo = TRUE, comment=">"}

library(Rcompadre)
data(Comadre)
data(Compadre)
  
```
The two databases are identical in gross structure, so the following code will apply to both.

Let's imagine you want to get matrices for all *Ursus maritimus* (polar bear) species from the database.

Once you have loaded the file, you should see it in your `Environment`. It will be called `Comadre` and is a stored as a formal class `CompadreData` (the class is the same for both COMPADRE and COMADRE).

### A quick note about S4 addressing
`Rcompadre` utilizes S4 objects to house the data. If you are already familiar with them, skip ahead. If not, the main thing you will need to remember is that accessing components of an S4 object is a bit different than accessing components of an S3 object (e.g. a data.frame or list). S4 objects are addressed using the **@** symbol rather than the **$** symbol. If you're interested in learning more, a far more comprehensive overview of how S4 objects work can be found [here](http://adv-r.had.co.nz/S4.html). And now, back to the demography!

You can check the structure of the object by typing the following, whereupon you will see there are 3 parts:

```{r, comment=">"}

slotNames(Comadre)
```

The `metadata` part is a dataframe that contains information about the matrix models contained in the database.

There are lots of columns in the dataframe, and you could subset the data by any of them.

```{r, comment=">"}

names(Comadre@metadata)
```

You can find the details of what these columns are in the User Guides or by running `?Comadre`.

Since we are interested in getting data for a species matching a particular name (*Ursus maritimus*), we'll need to examine the column called `SpeciesAccepted`, which is the currently accepted binomial species name. `RCompadre` provides a suite of utility functions to make working with the data base a bit easier. We'll use the `subsetDB` function to find all the matrices for _Ursus maritimus_.

```{r, echo = TRUE, comment = ">"}

PolarBears <- subsetDB(db = Comadre, sub = SpeciesAccepted == 'Ursus maritimus')

```

To get the matrix for any of these we need to access the `mat` part of the database.

Let's look at the first one using `PolarBears@mat[[1]]`

You will note that `mat` actually consists of 5 objects: a  called dataframe called `matrixClass` and 4 separate matrices called `matA`, `matU`, `matF` and `matC`. The  matrix most of you will want is the **A** matrix. The others are sub-parts of this matrix that represent processes of survival, fertility and clonality. These three matrices sum to the **A** matrix.


You can isolate **just** the **A** matrix like this, renaming it `x`:

```{r comment=">"}
x <- PolarBears@mat[[1]]@matA
x
```

Now you can use this matrix to do the analysis of interest.

You'll probabaly note that the stage class information is omitted from `matA`. To access this information directly, you can call `PolarBears@mat[[1]]@matrixClass`

## Plot a life cycle diagram

The exercise plots a life cycle with the stages and transitions of a give matrix chosen from the `Comadre` (or `Compadre`) database (or indeed elsewhere). It will use the R function `plotLifeCycle` from the `Rage` library. This function works well with matrices of relatively low dimensionality (~< 7), and where not many transitions are depicted. 

```{r, comment=">"}
library(Rage)
```

Let's plot the lifecycle described by the `A` matrix for a species containing the word "lion" in the common name used by the author(s) in the original source publiction.

```{r echo=FALSE}
data(Comadre)
```

To subset the species with the word `lion` in their common name, we use the function `grepl`.

```{r, comment=">"}
Lions <- subsetDB(db = Comadre, sub = grepl('lion', Comadre@metadata$CommonName))
unique(Lions@metadata$CommonName)
```

Unfortunately, no actual lion (*Panthera leo*) has been included in this version of COMADRE, but there are plenty of other "lions" in it. We will plot the life cycle of the red lionfish (*Pterois volitans*):

```{r, comment=">"}
matNum <- which(Lions@metadata$CommonName == "Red lionfish")
matNum
sp <- gsub("_", " ", Lions@metadata$SpeciesAccepted[matNum])
sp
```

The matrix 'A' and the stages of this study are:

```{r, comment=">"}
matA <- Lions@mat[[matNum]]@matA
matA
stages <- Lions@mat[[matNum]]@matrixClass$MatrixClassAuthor
stages
```

To plot its lifecycle, use the function `plotLifeCycle.R` from the `Rage` package. 


```{r eval =FALSE}
plotLifeCycle(matA, title = "Red lionfish")
```

## Simple outputs
This example produces some basic output such as the population growth rate ($\lambda$) and damping ratio (Caswell 2001) for a subset of species and populations given some selection criteria.

```{r echo=FALSE}
data(Comadre)
library(Rage)
```

First, use `subsetDB` (from the `Mage` package) to subset the database to the data of interest: only mean matrices for bony fish from studies of 3 years duration or longer, and with a  matrix dimension of 3 or greater.

```{r, comment=">"}
BonyFish <- subsetDB(Comadre, MatrixComposite == "Mean" &
                              Class == "Actinopterygii" &
                              StudyDuration >= 3 &
                              MatrixDimension > 3)
```

These matrices can now be analyzed by applying functions in a loop, or by using `lapply`.

For example, to calculate population growth rate and damping ratio for
the subset of matrices, first create an empty `data.frame` to accommodate the output

```{r, comment=">"}
output <- data.frame(lambdas = rep(NA, length(BonyFish@mat)),
                     damps = rep(NA, length(BonyFish@mat)))
```

and then use the functions in `popbio` package to derive demographic output (the user may need to install the package first).

```{r, comment=">"}
library(popbio)
```


```{r, comment=">"}
for (i in seq_len(length(BonyFish@mat))){
    output$lambdas[i] <- Re(eigen(BonyFish@mat[[i]]@matA)$value)[1]
    output$damps[i] <- damping.ratio(BonyFish@mat[[i]]@matA)
}
```

To examine the output:

```{r, comment=">"}
output
```

These parameters are presented in the same order as the `metadata` so we could also add the species name to this `data.frame`:

```{r, comment=">"}
data.frame(Species = BonyFish@metadata$SpeciesAccepted, output)
```

Plot the population growth rates and damping ratios derived from these matrices. In this plot, the vertical, dashed red line indicates that the population growth rate = 1 (or log ($\lambda$) = 0)

```{r, comment=">", fig.height=5, fig.width=7}
par(mfrow = c(1,2))
hist(log(output$lambdas),
     xlab = expression(paste('Log(', lambda,')')),
     col = "gold", main = "")
abline(v=0,col = "red", lwd = 4, lty = 3)
hist(output$damps, xlab = "Damping ratio",
     col = "brown", main = "")
```

## Geographic distribution

This example produces on a world map the viability (population growth rate $\lambda$ > 1, $\lambda$ = 1, $\lambda$ < 1) of a subset of studied populations given some selection criteria, and color-codes the location of each population according to the value of $\lambda$.

First, subset mean matrices for all Carnivora in the wild in the northern hemisphere, with no instances for survival > 1, for which matrices have been split into **A** = **U** + **F** + **C**, and for which reproduction was explicitly modeled.


```{r echo=FALSE}
library(Rage)
data(Comadre)
```

```{r, comment=">"}
Carnivores <- subsetDB(Comadre, MatrixComposite == "Mean" &
                                Order == "Carnivora" &
                                MatrixCaptivity == "W" &
                                Lat > 0 &
                                SurvivalIssue < 1 &
                                MatrixSplit == "Divided" &
                                MatrixFec == "Yes")
```

To calculate population growth rate for the subset matrices, we can first create an empty `data.frame` to accommodate the output:

```{r, comment=">"}
output <- data.frame(lambdas = rep(NA, length(Carnivores@mat)))
```


Or create an empty variable in the `metadata` data frame to accommodate output from lambda calculations:

```{r, comment=">"}
Carnivores@metadata$lambdas <- NA
```


Then, create a `for` loop to examine each matrix in turn. Here it may be advisable to use the function `tryCatch` as a wrapper to cope with the situation if/when the function in the loop fails:

```{r, comment=">"}
for (i in seq_len(length(Carnivores@mat))){
  tryCatch({
    Carnivores@metadata$lambdas[i] <- Re(eigen(Carnivores@mat[[i]]@matA)$value)[1]
  }, error = function(e){})
}
```

Now we can create a vector of color hex codes that can be applied according to the estimate of $\lambda$. This is done using the `colorRampPalette` function to go from green for high values of $\lambda$, to red for low values of $\lambda$. Here `paste` is used to append a value of `90` to the hex codes to allow transparency for aesthetic reasons.

```{r, comment=">"}

rampfunc <- colorRampPalette(c("green", "red"))
colVect <- rampfunc(100)
colVect <- paste(colVect, "90", sep = "")
s1 <- seq(min(Carnivores@metadata$lambdas, na.rm=TRUE),
          max(Carnivores@metadata$lambdas, na.rm=TRUE),
          length.out = 100)
```

First, load the `maps` package (and install it if necessary). Then plot the world map and overlay the points from our data, color coded by value of $\lambda$. In this case, the points are jittered slightly to improve visibility of nearby populations.

```{r, comment=">", fig.height=6, fig.width=8}
library(maps)
map("world", col = "gray", fill = TRUE, bg = "light blue",
    xlim = c(-175, 176), ylim = c(-60, 85), border = "white")

points(jitter(Carnivores@metadata$Lon, 0.6), 
       jitter(Carnivores@metadata$Lat, 0.6),
       col = colVect[findInterval(Carnivores@metadata$lambdas, s1)],
       cex = 2, 
       pch = 16)
```

## Ternary plots


```{r echo=FALSE}
data(Comadre)
```

Here we produce a ternary plot *a la* Silvertown & Franco (1993) with various life history traits such as mean life expectancy, population growth rate or reactivity as the "fourth" dimension. We will use Caswell (2001) formulation of mean life expectancy from the fundamental matrix (`N`), and the package `popdemo` for the reactivity. Other packages we need include `Rage`, `fields`, `vcd` and `scales`:

```{r, comment=">", message = FALSE, warning = FALSE}
library(popdemo)
library(fields)
library(Rage)
library(vcd)
library(scales)
```

This is the function to calculate mean life expectancy from Caswell (2001):

```{r, comment = ">"}
meanLifeExpectancy <- function(matU = matU, startLife = 1){
  uDim <- dim(matU)[1]
  N <- solve(diag(uDim[startLife]) - matU)
  eta <- colSums(N)[startLife]
  return(eta)
}
```

As an example for the chosen data, subset COMADRE to studies with a matrix dimension >= 3, that represent mean, unmanipulated conditions duration > 3 years, where sexual reproduction has been modeled explicitly, the matrices are split into U, F and C, and there are no issues with stage-specific survival >1.

```{r, comment=">"}
ExData <- subsetDB(Comadre, MatrixDimension >= 3  &
                            MatrixComposite == "Mean" & 
                            MatrixTreatment == "Unmanipulated" & 
                            StudyDuration > 3 & 
                            MatrixFec == "Yes" & 
                            MatrixSplit == "Divided" & 
                            SurvivalIssue < 1)
```

This object (`ExData`) is now a copy of the database that contains ONLY the matrices of interest.

We can ask how many matrices this is by looking at the size of the metadata part.

```{r, comment = ">"}
nrow(ExData@metadata)
```

These matrices can now be analyzed by applying functions in a loop, or by using `lapply`.

To calculate elasticities, population growth rate, reactivity and mean life expectancy for the subset matrices, first create an empty `data.frame` to accommodate the output:

```{r, comment=">"}
output <- data.frame(species= rep(NA, nrow(ExData@metadata)),
                     lambda = rep(NA, nrow(ExData@metadata)),
                     eta = rep(NA, nrow(ExData@metadata)),
                     react = rep(NA, nrow(ExData@metadata)),
                     EStasis = rep(NA, nrow(ExData@metadata)),
                     EProgression = rep(NA, nrow(ExData@metadata)),
                     ERetrogression = rep(NA, nrow(ExData@metadata)),
                     EFecundity = rep(NA, nrow(ExData@metadata)),
                     EClonality = rep(NA, nrow(ExData@metadata)))
```

We will use the `Mage` function `matrixElementPerturbation` to calculate element-level perturbations for each matrix in a `for` loop:

```{r, comment=">", warning = FALSE}
for (i in seq_len(nrow(ExData@metadata))){
 tryCatch({
    output$species[i] <- ExData@metadata$SpeciesAuthor[i]
    
    output$lambda[i] <- max(Re(eigen(ExData@mat[[i]]@matA)$value))
    
    output$eta[i] <- meanLifeExpectancy(matU = ExData@mat[[i]]@matU, 
                                        startLife = 1)
    
    output$react[i] <- reac(ExData@mat[[i]]@matA, bound = "upper")
    
    output[i, c("EStasis","EProgression", "ERetrogression",
               "EFecundity", "EClonality")] <- 
      matrixElementPerturbation(matU = ExData@mat[[i]]@matU, 
                                matF = ExData@mat[[i]]@matF, 
                                matC = ExData@mat[[i]]@matC)[6:10]
      }, error = function(e){})
}
```

Now we can group elasticities of population growth rate to various demographic processes into three axes of our ternary plot:

```{r, comment=">"}
output$S <- output$EStasis + output$ERetrogression
output$G <- output$EProgression
output$R <- output$EFecundity + output$EClonality
```

We need to scale the coordinates of each point between 0 and 1 - this is necessary due to possible rounding issues:

```{r, comment=">"}
output$S <- output$S / rowSums(output[, c("S","G","R")])
output$G <- output$G / rowSums(output[, c("S","G","R")])
output$R <- output$R / rowSums(output[, c("S","G","R")])
```

Normally, you would then need to eliminate the few MPMs where the code did not run correctly and produced `NA` values. This didn't happen in this example, but the code to do this is below.

```{r, comment=">"}
output <- output[-which(is.na(output$eta)), ]
```

Now we can finally plot the locations of the chosen matrices in a preliminary ternary plot using the function `ternaryplot` from the package `vcd`. The following code also uses the function `alpha` from the `scales` package to modify the colour transparency of the points.

```{r, comment=">", tidy.opts=list(width.cutoff=50), eval = FALSE}
ternaryplot(as.matrix(output[ ,c("R", "S", "G")]),
            scale = 1,
            col = alpha("gray80", 0.7),
            bg = "black",
            dimnames = c("Stasis", "Growth", "Reproduction"),
            dimnames_position = "edge", 
            main = "Preliminary plot")
```


As a use extension to this ternary plot, we can colour-code the points according to the values of lambda, eta or reactivity. To do that we first need to set up a colour palette for each of these measures, and deduce which colour each point should have.


In every case we can use the same `colorRamp` function to deduce the appropriate colour:

```{r, comment=">"}
col_fun <- colorRamp(c("white", "yellow", "orange", "red", "dark red"))
```

First, lambda.  For this measure we should first subset out the data with unreasonable values (say > 7):

```{r, comment=">"}
lambdaData <- subset(output, lambda < 7)
```

We then log transform and standardize the values, and obtain the hex colour codes for each point using the `rgb` function:

```{r, comment=">"}
Z <- log(lambdaData$lambda)
zNorm <- (Z - min(Z))/(max(Z) - min(Z))
colsLambda <- rgb(col_fun(zNorm), maxColorValue = 256)
```

We can now plot this diagram:

```{r, comment=">", warning=FALSE, eval = FALSE}
ternaryplot(as.matrix(lambdaData[, c("R", "S", "G")]),
            scale = 1, 
            col = alpha(colsLambda, 0.7),
            bg = "black", 
            dimnames = c("Stasis", "Growth", "Reproduction"),
            dimnames_position = "edge", 
            main = expression(paste("Population growth rate - ", lambda)))
```


Second, mean life expectancy (eta):

```{r, comment=">"}
etaData <- output
Z <- log(etaData$eta)
zNorm <- (Z - min(Z))/(max(Z) - min(Z))
colsEta <- rgb(col_fun(zNorm), maxColorValue = 256)
```

For which the plot can be genarated like this, as before:

```{r, comment=">", warning=FALSE, eval = FALSE}
ternaryplot(as.matrix(etaData[, c("R", "S", "G")]), 
            scale = 1, 
            col = alpha(colsEta, 0.7),
            bg = "black", 
            dimnames = c("Stasis", "Growth", "Reproduction"),
            dimnames_position = "edge", 
            main=expression(paste("Mean life expectancy - ", eta["e"])))

```

Thirdly, reactivity:

```{r, comment=">"}
reactData <- subset(output, react < 140)
Z <- log(reactData$lambda)
zNorm <- (Z - min(Z))/(max(Z) - min(Z))
colsReact <- rgb(col_fun(zNorm), maxColorValue = 256)
```

And the plot:

```{r, comment=">", warning=FALSE, eval = FALSE}
ternaryplot(as.matrix(reactData[, c("R", "S", "G")]),
            scale = 1, 
            col = alpha(colsReact, 0.7),
            bg = "black", 
            dimnames = c("Stasis", "Growth", "Reproduction"),
            dimnames_position = "edge", 
            main = expression(paste("Reactivity - ||", hat(A),"||"[1])))

```

One could add the color scale legend using the following code to add to the same plot. Note though, that here the value of the points has been standardised to range from 0 to 1, rather than the original lambda/eta/reactivity values:

```{r, eval = FALSE, warning=FALSE, eval = FALSE}
colCode <- colorRampPalette(c("white", "yellow", "orange", "red", "dark red"))(n = 999)
image.plot(legend.only = TRUE,
           zlim = range(zNorm), 
           col = colCode, 
           smallplot = c(.75, .8, .5, .75),
           cex.axis = 0.2) 
```

## Age from stage


It is possible to obtain `lx` and `mx` schedules from matrix population models using methods described by Caswell (2001). There is a function `makeLifeTable` in our `Rage` package, that implements this.

Here is an example.

```{r echo=FALSE}
data(Comadre)
library(Rage)
library(MASS)
```

Next, query the `metadata` part of `Comadre` to identify the location of the desired data using the command `which` in a conditional search:

```{r comment=">"}
id <- which(Comadre@metadata$SpeciesAccepted == "Pterois volitans")
id
```


Let's pick the first matrix of the list obtained above:

```{r comment = ">"}
lt1 <- makeLifeTable(matU = Comadre@mat[[id[1]]]@matU,
                     matF = Comadre@mat[[id[1]]]@matF,
                     startLife = 1, 
                     nSteps = 10)
lt1
```

## Obtaining references

The following example illustrates how to check and find the full references and DOI for the publications used in COMADRE. See also Supporting Information Appendix S4 below.

The code relies on the package `rcrossref` (https://github.com/ropensci/rcrossref) which queries *CrossRef*, an official Digital Object Identifier (DOI) Registration Agency of the International DOI Foundation. Thus you will first need to load the package (and install it if necessary):

```{r,eval=FALSE,echo=FALSE}
install.packages("rcrossref")
```

```{r, comment=">"}
library(rcrossref)
library(dplyr)
```

The `rcrossref` package has a convenient function, `cr_search_free` which conducts a free-text search of the CrossRef database. To use it, one needs to provide some query text, so in this case we can simply create a text string by concatenating the authors, journal and year of publication from COMADRE. 

For example, to obtain the full references for all the studies used to create the plots above, first extract the column `DOI.ISBN` from the `ExData` object and remove any that don't have a DOI or ISBN number.

```{r,comment=">"}
DOIs <- ExData@metadata$DOI.ISBN %>%
  .[!is.na(.)]
```

Armed with the DOIs, it is easy to obtain the full title, author list etc. from CrossRef in a range of formats using the function `cr_cn`. 

```{r,comment=">"}

Citations <- cr_cn(dois = DOIs, format = "text", style = "apa")
```

Be aware that running this for a large number of studies may take a bit of time and adjust your expectations accordingly. 

## Checking taxonomy 

The following R code illustrates how to update the taxonomy used in COMADRE using the R package `taxize` (Chamberlain & SzÃ¶cs 2013) to query the Catalogue of Life (http://www.catalogueoflife.org) with the names used by the source publication authors in COMADRE. 

The function `classification` in `taxize` allows the programmatic querying of databases including the Catalogue of Life. For example:

```{r,eval = TRUE,echo=TRUE}
library(taxize)
```


```{r,comment=">"}
classification("Daphnia magna", db = 'col')
```

One can capitalise on this for COMADRE. 

First load the required package, `taxize`.

```{r, warning = FALSE, message = FALSE}
library(taxize)
library(stringr)
library(dplyr)
```

Now make a new vector called `SpeciesBinomial` by concatenating the accepted genus and author supplied species names together. This is necessary, rather than simply using `SpeciesAccepted`, because `SpeciesAccepted` retains the infra-specific information which is not used by the following code.  Additionally, Some species do not have an epithet (e.g. *Cottus* sp.). Therefore, to search the Catalogue of Life effectively, we need to remove the 'sp.' text and trim off the trailing whitespaces. We'll make use of the pipe (`%>%`) operator to streamline our code a bit too.


```{r, comment=">"}
ExData@metadata$SpeciesBinomial <- vapply(ExData@metadata$SpeciesAuthor, 
                                          FUN = function(x) stringr::str_split(x, '_')[[1]][2],
                                          FUN.VALUE = '') %>%
  paste(ExData@metadata$Genus, .,  sep = ' ') %>%
  gsub('sp\\.', '', .) %>%
  str_trim()

```


Because species appear in the database numerous times it is advisable for efficiency reasons to make a unique subset of the data:

```{r, comment=">"}
temp <- unique(ExData@metadata[, c("SpeciesBinomial", 
                                   "Genus", "Family", 
                                   "Order", "Class", 
                                   "Phylum", "Kingdom")])
```

This dataset is still quite large (`r length(temp)` species), so here I will just obtain the information for the first 5 species.

```{r, comment=">"}
temp <- temp[1:5, ]
```

This is accomplished using the `classification` function which repeatedly queries the Catalogue of Life for each entry. In this case, we have asked it to only return 1 row as whenever there is an uncertainty as to which species is intended, the software prompts the user to select a species from a list. However, setting `rows` to a value > 1 will allow for interactive selection when there is more than 1 option.

```{r, comment=">"}
x <- classification(temp$SpeciesBinomial, db='col', rows = 1)
```

The object produced by this code is a `list` with elements corresponding to each species. Thus `x[[1]]` will return the first species etc. One can also address the list by element name, which is defined by the query that was submitted e.g. `x[["Acipenser fulvescens"]]`

```{r,comment=">"}
x[[1]]
```

Thus, to acquire the taxonomic Order of the species of interest one would use:

```{r,comment=">"}
x[[1]]$name[x[[1]]$rank == "order"]
```

One can run through this list object in a loop to compare the information held in COMADRE, with that produced by the query to Catalogue of Life. For example, to check the Orders of the 5 species held in `temp`

```{r,comment=">", tidy.opts=list(blank=TRUE, width.cutoff=60)}
temp$OrderOK <- NA

for(i in seq_len(length(temp$SpeciesBinomial))){
n <- temp$SpeciesBinomial[i]
dat <- x[[n]]
CoL_Order <- dat$name[dat$rank == "order"]
if(temp$Order[i] == CoL_Order){
  temp$OrderOK[i] <- "OK"
} else {
    temp$OrderOK[i] <- "Differs!"}
}
```

which will add an extra column called `OrderOK` to the `temp` data frame:

```{r,comment=">"}
temp
```
This approach can naturally be repeated for each part of the taxonomy.

## Useful links

The COMPADRE and COMADRE website http://www.compadre-db.org (download the latest data files from here).


[COMPADRE User Guide PDF](https://github.com/jonesor/compadreDB/raw/master/COMPADRE-UserGuide/COMPADRE-UserGuide.pdf)


[COMADRE User Guide PDF](https://github.com/jonesor/compadreDB/raw/master/COMADRE-UserGuide/COMADRE-UserGuide.pdf)
